DB / DRIZZLE / CONNECTION POOLING – AUDIT + FIX (Supabase + Render-ready)
=========================================================================

CONTEXT
=======
We run ContainerFlow with:
- Backend: Node.js + Express
- ORM: Drizzle
- Database: Supabase PostgreSQL (using DATABASE_URL, preferably Transaction/Pooler)
- Hosting target: Render (or similar)

We have had build/runtime issues and want to ensure the database layer is correct, stable, and production-ready.

GOAL
====
Please audit and correct our Drizzle + PostgreSQL connection setup so that:
- We use ONE shared pg Pool instance (not creating new connections per request)
- Supabase Pooler (Transaction mode) works reliably
- SSL is handled correctly
- Health-checks really validate DB connectivity
- Debugging information is available (pool stats + error clarity)
- No “too many connections”, DNS, or intermittent DB timeouts
- Drizzle is initialized correctly and consistently used everywhere

IMPORTANT:
- Do NOT change business logic (tasks, containers, QR, roles).
- Only improve DB connection + Drizzle configuration and verification.

-----------------------------------------------------------------------
PART 1 — FIND CURRENT DB INITIALIZATION AND FIX IT
-----------------------------------------------------------------------

1) Locate where the database is created (likely server/db.ts or similar).
2) Ensure we create the PostgreSQL pool only once at process startup:
   - `new Pool(...)` must NOT be inside request handlers, routers, or services.
3) Ensure Drizzle uses that pool (not a new client each time).

Target structure (example):

- Create `pool` once
- Export `pool` and `db` for reuse across routes/services

Pseudo:

import { Pool } from "pg";
import { drizzle } from "drizzle-orm/node-postgres";

const pool = new Pool({...});
export const db = drizzle(pool);

-----------------------------------------------------------------------
PART 2 — SUPABASE POOLER (TRANSACTION) COMPATIBILITY
-----------------------------------------------------------------------

1) Confirm we are using DATABASE_URL for Supabase Transaction/Pooler:
   - typically host contains ".pooler.supabase.com" and port 6543.
2) Add SSL configuration (required for Supabase in most environments):
   - ssl: { rejectUnauthorized: false }

3) Set safe pool parameters for a small/medium app:
   - max: 5–10
   - idleTimeoutMillis: 30000
   - connectionTimeoutMillis: 10000

4) Confirm no direct dependency uses “dynamic require” DB code that breaks runtime.

-----------------------------------------------------------------------
PART 3 — HEALTHCHECK MUST TEST DB FOR REAL
-----------------------------------------------------------------------

We already have /api/health. Make sure it executes a real DB query:

- Use `await pool.query("select 1 as ok")`
- Return:
  - 200 with {status:"ok", database:"connected", timestamp:"..."} on success
  - 503 with {status:"degraded", database:"disconnected", error:"...", timestamp:"..."} on failure

Ensure errors are not swallowed. Include err.message.

-----------------------------------------------------------------------
PART 4 — ADD TEMPORARY POOL DEBUG LOGGING
-----------------------------------------------------------------------

Add minimal, safe logging (can be behind env flag like DB_DEBUG=true):

- Every 30 seconds log:
  - pool.totalCount
  - pool.idleCount
  - pool.waitingCount

Example output:
[DB POOL] total=5 idle=3 waiting=0

This will help detect pool exhaustion.

-----------------------------------------------------------------------
PART 5 — ENSURE ALL ROUTES USE THE SAME DB INSTANCE
-----------------------------------------------------------------------

Audit codebase:
- Search for any new Pool() calls or multiple DB initializations.
- Ensure every route/service imports the shared `db` / `pool`.
- Remove any duplicate connection code.

If any function creates a new client/pool per request, refactor it.

-----------------------------------------------------------------------
PART 6 — DRIZZLE CONFIG SANITY CHECK
-----------------------------------------------------------------------

1) Ensure schema usage is consistent:
- If we use schema exports (shared/schema.ts), initialize drizzle with schema if appropriate.
- Ensure table references in queries match schema definitions.

2) Confirm drizzle-kit commands use DATABASE_URL:
- db:push should work reliably.

Note:
- If drizzle-kit DDL operations fail via transaction pooler, keep runtime using pooler but optionally document using Direct connection for migrations only.
- Do NOT break our runtime DATABASE_URL.

-----------------------------------------------------------------------
PART 7 — ADD A DB TEST ENDPOINT (TEMPORARY)
-----------------------------------------------------------------------

Add a simple endpoint for debugging (can be removed later):

GET /api/db-test
- runs: select now() as now
- returns the timestamp

This helps verify DB queries in production quickly.

-----------------------------------------------------------------------
PART 8 — ACCEPTANCE CRITERIA
-----------------------------------------------------------------------

After your changes:

1) `npm run server:dev` works.
2) `npm run server:build` and `npm run server:start` work.
3) `GET /api/health` reliably returns database connected.
4) No more intermittent DB connection failures.
5) No more “too many connections” issues.
6) No per-request Pool/Client creation.
7) Pool stats show waitingCount stays at 0 under normal use.

DELIVERABLE
===========

- Provide the updated DB initialization file (server/db.ts or equivalent).
- Show the updated /api/health implementation.
- Confirm you removed any duplicate DB initialization patterns.
- Include brief notes in README about required env vars:
  - DATABASE_URL (Supabase pooler)
  - NODE_ENV
  - PORT
  - optional: DB_DEBUG=true

DO NOT:
- Do not rewrite app logic.
- Do not add Supabase-js client to frontend.
- Do not remove Drizzle.
Only fix DB connection + pooling + verification.
