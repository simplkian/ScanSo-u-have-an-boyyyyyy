Du bist Lead Engineer (NestJS + Postgres + Expo React Native). Baue eine interaktive Werkskarte auf Basis der hochgeladenen PNG-Pläne und der CSV-Koordinaten. Ergebnis: Nutzer können visuell navigieren (Halle → Station → Stand), Tasks sehen und direkt aus der Karte heraus claimen/transitionieren (Open Queue: jeder sieht alles, jeder kann alles).

Inputs (liegen im Repo/Upload)

/assets/maps/OUT.png, K13.png, K18.png, K19.png, K25.png

/data/map_coordinates_seed.csv (Startkoordinaten)
Die Koordinaten sind “ungefähr” und müssen im Admin Map Editor nachjustierbar sein.

Datenmodell (gegeben, nutze vorhandene JSON-Felder)

halls(location_meta jsonb, qr_code text?) -> erweitern falls nötig

stations(location_meta jsonb, code text)

stands(position_meta jsonb, identifier text, material_id, station_id)

tasks(stand_id, status, scheduled_for, claimed_by_user_id, claimed_at, weight_kg, ...)

boxes(stand_id nullable, serial, qr_code)

task_events/activity_logs existieren

1) Map Assets & Hall-Metadaten

Lege Map-Dateien unter /assets/maps/ ab.

In halls.location_meta speichere:
{ "mapImageKey": "K19.png" } bzw. für Overview { "mapImageKey": "OUT.png" }.

Falls mapImageKey fehlt: fallback auf Liste statt Karte (keine Crashs).

2) CSV Importer (Server, Admin-only)

Implementiere einen Importer, der map_coordinates_seed.csv liest und Positionsdaten setzt:

Für entity_type=HALL: setze halls.location_meta.mapMarker = {x,y} (Marker auf OUT.png)

Für entity_type=STATION: setze stations.location_meta = {x,y} (Marker auf Halle-Map)
Matching-Regeln:

Hall Match über halls.code == hall_code

Station Match über stations.code == station_code
Schreibe Audit in activity_logs: action='MAP_IMPORT', meta_json enthält counts + before/after.

3) Admin Map Editor (Pflicht)

Admin Screen “Map Editor”:

Halle auswählen → Plan anzeigen

Marker anzeigen (Stationen/optional Stände)

Marker per Drag/Drop verschieben → PATCH auf Server:

PATCH /admin/stations/:id/position {x,y}

PATCH /admin/halls/:id/map-marker {x,y} (für OUT-Übersicht)

Optional: Stand Marker editor (PATCH /admin/stands/:id/position {x,y})
Alles auditen: activity_logs action='MAP_POSITION_UPDATED'.

4) User Map Screen (Pflicht)

Screen “Map”:
A) Overview (OUT):

Zeige OUT.png

Marker = Hallen (aus halls.location_meta.mapMarker)

Klick Halle → öffnet Hall Detail Map

B) Hall Map:

Zeige halls.location_meta.mapImageKey (z.B. K19.png)

Marker = Stationen (aus stations.location_meta x/y)

Marker zeigt Badge: Anzahl offener/heutiger Tasks in dieser Station

Klick Station → Bottom Sheet / Drawer mit:

Station Info

Liste Stände (identifier + Material)

Pro Stand: Box vorhanden? (live query boxes.stand_id) + offene Tasks

Klick Stand → Stand Detail (Modal)

C) Stand Detail Modal:

Stand identifier + Material (aus stands.material_id)

Aktuelle Box am Stand (live: boxes where stand_id)

Offene Tasks für stand_id

Task-Aktionen direkt möglich:

Claim/Release (TTL 30min)

Transition Buttons gemäß Statusmaschine

Gewicht-Eingabe verpflichtend beim Übergang TAKEN_OVER→WEIGHED
Open Queue Regeln: keine Zuweisung, jeder sieht alles.

5) Map-API Endpoints (performant)

GET /map/overview -> halls mit {id, code, name, mapMarker, mapImageKey}

GET /map/halls/:hallId -> stations mit {id, code, name, x,y, openTaskCountToday, openTaskCountAll}

GET /map/stations/:stationId -> stands mit {id, identifier, material, x,y (optional), boxPresent, openTaskCount}

GET /map/stands/:standId -> {currentBox, tasks[]}

Aggregation:

“openTaskCount” = status != DISPOSED/CANCELLED

“today” = scheduled_for ist heute ODER scheduled_for NULL aber status OPEN

6) Hinweis zur Genauigkeit

Die CSV-Koordinaten sind Startwerte. Map Editor muss Nachjustierung ermöglichen.

Output

Vollständiger Code: Backend + RN UI + Importer + Admin Map Editor

README_MAP.md mit: Asset-Pfade, Koordinatenformat (0..1), Import-Schritte